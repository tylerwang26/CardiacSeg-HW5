---
source: https://github.com/MIC-DKFZ/nnUNet?tab=readme-ov-file
title: MIC-DKFZ/nnUNet
tags:
  - clippings
related:
feature: Resources/thumbnails/external/2cb6b9295c2d29aedc357e2f3d84d4c4.png
thumbnail: Resources/thumbnails/resized/b5097617618421d3f3edd42d0940f855_b89e22fb.webp
---

什麼是nnU-Net？
影像資料集種類繁多：影像維度（2D、3D）、模態/輸入通道（RGB影像、CT、MRI、顯微鏡等）、影像大小、體素大小、類別比例、目標結構屬性等等，在不同的資料集之間都存在顯著差異。傳統上，面對一個新問題，需要手動設計和優化客製化的解決方案——這個過程容易出錯，難以擴展，而且成功與否很大程度上取決於實驗者的經驗。即使對專家來說，這個過程也絕非易事：不僅需要考慮眾多設計選擇和資料屬性，而且它們之間還緊密相連，使得可靠的手動流程優化幾乎不可能實現！

nnU-Net概述

nnU-Net 是一種語意分割方法，能夠自動適應給定的資料集。它會分析提供的訓練樣本，並自動配置匹配的基於 U-Net 的分割流程。您無需任何專業知識！只需訓練模型並將其用於您的應用程式即可。

發布後，nnU-Net 在 23 個生物醫學領域競賽資料集上進行了評估。儘管每個資料集都面臨著手工設計的解決方案，nnU-Net 的全自動流程仍然在公開排行榜上斬獲多個第一名！此後，nnU-Net 經受住了時間的考驗：它持續被用作基線和方法開發框架（MICCAI 2020 的 10 個挑戰賽冠軍中有 9 個，MICCAI 2021 的 7 個挑戰賽冠軍中有 5 個，都基於 nnU-Net 構建了他們的方法； 我們還憑藉 20-BNet 2020-20 205 的冠軍；

使用nnU-Net時請引用以下論文：

Isensee, F., Jaeger, P. F., Kohl, S. A., Petersen, J., & Maier-Hein, K. H. (2021). nnU-Net: a self-configuring 
method for deep learning-based biomedical image segmentation. Nature methods, 18(2), 203-211.
nnU-Net 能為您做些什麼？
如果您是領域科學家（生物學家、放射科醫生等），想要分析自己的影像，nnU-Net 提供了一個開箱即用的解決方案，幾乎可以保證在您的資料集上獲得卓越的分析結果。只需將您的資料集轉換為 nnU-Net 格式，即可享受人工智慧的強大功能—無需任何專業知識！

如果您是一位正在開發分割方法的AI 研究人員，那麼 nnU-Net：

提供了一個開箱即用、極具競爭力的基準演算法，可用於與其他演算法競爭。
可以作為方法開發框架，在大量資料集上測試您的貢獻，而無需調整單一管道（例如，評估新的損失函數）。
這為進一步針對特定資料集的最佳化提供了一個良好的起點。這在參加分割挑戰賽時尤其重要。
為分割方法的設計提供了一個新的視角：或許可以找到資料集屬性與最佳分割流程之間的更好連結？
nnU-Net 的應用範圍是什麼？
nnU-Net 專為語意分割而設計。它可以處理具有任意輸入模態/通道的 2D 和 3D 影像。它能夠理解體素間距和各向異性，即使在類別高度不平衡的情況下也具有穩健性。

nnU-Net 依賴監督學習，這意味著您需要為您的應用程式提供訓練樣本。所需的訓練樣本數量會根據分割問題的複雜程度而有很大差異。這裡無法提供一個通用的數字！ nnU-Net 所需的訓練樣本數量並不比其他解決方案多——由於我們廣泛使用了資料增強技術，甚至可能更少。

nnU-Net 需要在預處理和後處理過程中一次處理整個影像，因此無法處理超大型影像。作為參考：我們測試的圖像尺寸範圍從 40x40x40 像素到 1500x1500x1500 像素（3D），以及從 40x40 像素到約 30000x30000 像素（2D）！如果您的記憶體允許，處理更大的圖像也是可以的。

nnU-Net 的工作原理是什麼？
給定一個新的資料集，nnU-Net 將系統地分析提供的訓練樣本，並建立一個「資料集指紋」。然後，nnU-Net 會為每個資料集建立多個 U-Net 配置：

2d：一個 2D U-Net（適用於 2D 和 3D 資料集）
3d_fullres：適用於高解析度影像的 3D U-Net（僅適用於 3D 資料集）
3d_lowres→ 3d_cascade_fullres：一個 3D U-Net 級聯，其中首先使用一個 3D U-Net 對低解析度影像進行操作，然後使用第二個高解析度 3D U-Net 來改進前者的預測結果（僅適用於影像尺寸較大的 3D 資料集）。
請注意，並非所有資料集都會建立所有 U-Net 配置。對於影像尺寸較小的資料集，會省略 U-Net 級聯（以及對應的 3d_lowres 配置），因為全解析度 U-Net 的影像區塊大小已經覆蓋了輸入影像的大部分。

nnU-Net 依照以下三個步驟配置其分割管道：

固定參數不進行調整。在 nnU-Net 的開發過程中，我們確定了一個穩健的配置（即特定的架構和訓練屬性），可以始終直接使用。這包括例如 nnU-Net 的損失函數、（大部分）資料增強策略和學習率。
基於規則的參數利用資料集指紋，透過遵循硬編碼的啟發式規則來調整某些分割流程屬性。例如，網路拓撲結構（池化行為和網路架構深度）會根據影像區塊大小進行調整；在給定GPU記憶體約束的情況下，影像區塊大小、網路拓撲結構和批次大小會進行聯合最佳化。
經驗參數本質上是反覆試驗的結果。例如，針對給定的資料集（2D、3D 全解析度、3D 低解析度、3D 級聯）選擇最佳的 U-net 配置，以及最佳化後處理策略。

nnU-Net 在哪些方面表現良好，在哪些方面表現不佳？
nnU-Net 擅長解決需要從頭開始訓練的分割問題，例如：具有非標準影像模態和輸入通道的研究應用、來自生物醫學領域的挑戰性資料集、大多數 3D 分割問題等等。我們至今還沒有發現任何 nnU-Net 的工作原理失效的資料集！

注意：對於標準的分割問題，例如 ADE20k 和 Cityscapes 中的 2D RGB 影像，微調一個基礎模型（該模型在大規模相似影像語料庫上預先訓練，例如 ImageNet 22k、JFT-300M）將比 nnU-Net 提供更好的效能！這只是因為這些模型可以實現更好的初始化。 nnU-Net 不支援基礎模型，因為它們：1) 不適用於偏離標準設定的分割問題（請參閱上述資料集）；2) 通常只支援 2D 架構；3) 與我們為每個資料集精心調整網路拓撲結構的核心設計原則相衝突（如果拓撲結構發生改變，就無法再遷移預訓練權重！）。

舊版 nnU-Net 發生了什麼事？
舊版 nnU-Net 的核心部分是在 2018 年參加醫療分割十項全能挑戰賽期間倉促拼湊而成的。因此，程式碼結構和品質都不盡人意。後來增加的許多功能與 nnU-Net 的設計原則並不完全契合。總而言之，程式碼相當混亂，而且使用起來也很麻煩。

nnU-Net V2 是徹底的重構，可以說是「推倒重來」式的。因此，一切都變得更好了（作者個人觀點，哈哈）。雖然分割效能保持不變，但新增了許多很棒的功能。現在，它作為開發框架使用起來也更加便捷，並且可以根據新的資料集手動微調其配置。推動此次重構的一大因素是亥姆霍茲成像技術的出現，這促使我們將 nnU-Net 擴展到更多影像格式和領域。點擊此處查看一些亮點。

---

# 修復 PyTorch 降級錯誤
從錯誤訊息看，問題是 PyTorch 沒有官方的 "2.8.0" 版本（nnU-Net GitHub 的說明可能有打字錯誤或過時；PyTorch 2.x 系列從 2.0.0 開始，之前是 1.13.1）。此外，torchvision==0.9.0 是舊版（對應 PyTorch 1.8.x），無法與 torch 2.x 兼容。這導致安裝失敗。

nnU-Net v2 支持 PyTorch 2.x，但 GitHub 提到某些 2.x 版本（如 2.3.0+）有 3D 卷積 + AMP 性能問題。建議降級到 PyTorch 2.0.0（第一個穩定 2.x 版本，無已知 nnU-Net 問題，對應 torchvision 0.15.0 和 torchaudio 0.15.0）。這是安全的 "lower" 版本，且兼容 CUDA 11.8（從您的 nvcc --version 假設；如果不同，請檢查）。

## 步驟
（在 VS Code 終端機或命令提示字元中執行）
直接在命令列（prompt/CMD）安裝 PyTorch 2.8.0 及其對應 CUDA 版本，步驟如下：

## 1. 查詢顯卡支援的 CUDA 版本
- 在命令列輸入 `nvidia-smi`，即可看到目前可用的 CUDA 版本，例如 CUDA 12.8 或 12.6 等。[1]

## 2. 安裝 CUDA Toolkit
- 前往 NVIDIA 官方下載對應版本的 CUDA Toolkit，安裝完成並配置環境變數。[2][3]

## 3. 安裝 PyTorch 2.8.0
pip install torch==2.8.0 --index-url https://download.pytorch.org/whl/cu128

(PyTorch 2.8.0 相容於 python 3.11)